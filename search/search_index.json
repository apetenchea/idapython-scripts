{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IDAPython Scripts","text":"<p>A growing collection of bite-sized IDAPython scripts and examples for automating and extending IDA Pro. Currently work in progress, but feel free to contribute or suggest new ideas!</p> <p>Source is available on GitHub. Pull requests are welcome!</p>"},{"location":"core/enumerate_segments/","title":"Enumerate Segments","text":"<p>Walks all segments in the loaded database, printing each segment\u2019s name, start/end addresses, and permissions.</p> <pre><code>import sys\n\nimport ida_pro\nimport ida_segment\nimport idaapi\nimport idautils\nimport idc\n\n\ndef format_perms(perm):\n    \"\"\"\n    Turn the segment permission bits into an R/W/X string.\n    \"\"\"\n    return \"\".join([\n        \"R\" if perm &amp; idaapi.SEGPERM_READ else \"-\",\n        \"W\" if perm &amp; idaapi.SEGPERM_WRITE else \"-\",\n        \"X\" if perm &amp; idaapi.SEGPERM_EXEC else \"-\"\n    ])\n\n\ndef format_type(typ):\n    \"\"\"\n    Turn the segment type into a string.\n    \"\"\"\n    result = \"\"\n    if typ == ida_segment.SEG_NORM:\n        result = \"unknown type, no assumptions\"\n    elif typ == ida_segment.SEG_XTRN:\n        result = \"segment with 'extern' definitions\"\n    elif typ == ida_segment.SEG_CODE:\n        result = \"code segment\"\n    elif typ == ida_segment.SEG_DATA:\n        result = \"data segment\"\n    elif typ == ida_segment.SEG_IMP:\n        result = \"java: implementation segment\"\n    elif typ == ida_segment.SEG_GRP:\n        result = \"group of segments\"\n    elif typ == ida_segment.SEG_NULL:\n        result = \"zero-length segment\"\n    elif typ == ida_segment.SEG_UNDF:\n        result = \"undefined segment type (not used)\"\n    elif typ == ida_segment.SEG_BSS:\n        result = \"uninitialized segment\"\n    elif typ == ida_segment.SEG_ABSSYM:\n        result = \"segment with definitions of absolute symbols\"\n    elif typ == ida_segment.SEG_COMM:\n        result = \"segment with communal definitions\"\n    elif typ == ida_segment.SEG_IMEM:\n        result = \"internal processor memory &amp; sfr (8051)\"\n    return result\n\n\ndef main(output):\n    # Iterate over all segments.\n    # It enumerates the starting address of each segment, in ascending order.\n    for ea in idautils.Segments():\n        # Get the segment object associated with the address.\n        seg: ida_segment.segment_t = ida_segment.getseg(ea)\n\n        # The name property is just an index in a global array of names.\n        # You need to use the get_segm_name function to get the actual name.\n        name = ida_segment.get_segm_name(seg)\n\n        # Each segment has its [start, end) addresses and represents\n        # a contiguous range. The end address is excluded from the segment.\n        start = seg.start_ea\n        end = seg.end_ea\n\n        # Permissions and type.\n        perms = format_perms(seg.perm)\n        typ = format_type(seg.type)\n\n        print(\n            f\"{name}: {hex(start)} - {hex(end)} ({perms}) {typ}\",\n            file=output\n        )\n\n\nif __name__ == \"__main__\":\n    if len(idc.ARGV) &gt; 1:\n        with open(idc.ARGV[1], \"w\") as f:\n            main(f)\n            f.flush()\n    else:\n        main(sys.stdout)\n    ida_pro.qexit(0)\n</code></pre>"}]}